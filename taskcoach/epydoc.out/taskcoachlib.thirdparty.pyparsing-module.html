<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>taskcoachlib.thirdparty.pyparsing</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="taskcoachlib-module.html">Package&nbsp;taskcoachlib</a> ::
        <a href="taskcoachlib.thirdparty-module.html">Package&nbsp;thirdparty</a> ::
        Module&nbsp;pyparsing
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="taskcoachlib.thirdparty.pyparsing-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module pyparsing</h1><p class="nomargin-top"><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html">source&nbsp;code</a></span></p>
<hr />
<div class="fields">      <p><strong>Version:</strong>
        1.5.5
      </p>
      <p><strong>Author:</strong>
        Paul McGuire &lt;ptmcg@users.sourceforge.net&gt;
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Classes</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Classes"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="str-class.html" class="summary-name" onclick="show_private();">basestring</a><br />
      str(object='') -&gt; string
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="xrange-class.html" class="summary-name" onclick="show_private();">range</a><br />
      xrange(stop) -&gt; xrange object xrange(start, stop[, step]) -&gt; 
        xrange object
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing._Constants-class.html" class="summary-name" onclick="show_private();">_Constants</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseBaseException-class.html" class="summary-name">ParseBaseException</a><br />
      base exception class for all parsing runtime exceptions
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseException-class.html" class="summary-name">ParseException</a><br />
      exception thrown when parse expressions don't match class; supported 
      attributes by name are:
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseFatalException-class.html" class="summary-name">ParseFatalException</a><br />
      user-throwable exception thrown when inconsistent parse content is 
      found; stops all parsing immediately
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseSyntaxException-class.html" class="summary-name">ParseSyntaxException</a><br />
      just like <code>ParseFatalException</code>, but thrown internally 
      when an <code>ErrorStop</code> ('-' operator) indicates that parsing 
      is to stop immediately because an unbacktrackable syntax error has 
      been found
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.RecursiveGrammarException-class.html" class="summary-name">RecursiveGrammarException</a><br />
      exception thrown by <code>validate()</code> if the grammar could be
        improperly recursive
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing._ParseResultsWithOffset-class.html" class="summary-name" onclick="show_private();">_ParseResultsWithOffset</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseResults-class.html" class="summary-name">ParseResults</a><br />
      Structured parse results, to provide multiple means of access to 
        the parsed data:
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParserElement-class.html" class="summary-name">ParserElement</a><br />
      Abstract base level parser element class.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Token-class.html" class="summary-name">Token</a><br />
      Abstract <code>ParserElement</code> subclass, for defining atomic 
      matching patterns.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Empty-class.html" class="summary-name">Empty</a><br />
      An empty token, will always match.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.NoMatch-class.html" class="summary-name">NoMatch</a><br />
      A token that will never match.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Literal-class.html" class="summary-name">Literal</a><br />
      Token to exactly match a specified string.
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Literal-class.html" class="summary-name" onclick="show_private();">_L</a><br />
      Token to exactly match a specified string.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Keyword-class.html" class="summary-name">Keyword</a><br />
      Token to exactly match a specified string as a keyword, that is, it 
      must be immediately followed by a non-keyword character.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.CaselessLiteral-class.html" class="summary-name">CaselessLiteral</a><br />
      Token to match a specified string, ignoring case of letters.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.CaselessKeyword-class.html" class="summary-name">CaselessKeyword</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Word-class.html" class="summary-name">Word</a><br />
      Token for matching words composed of allowed character sets.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Regex-class.html" class="summary-name">Regex</a><br />
      Token for matching strings that match a given regular expression.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.QuotedString-class.html" class="summary-name">QuotedString</a><br />
      Token for matching strings that are delimited by quoting characters.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.CharsNotIn-class.html" class="summary-name">CharsNotIn</a><br />
      Token for matching words composed of characters *not* in a given set.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.White-class.html" class="summary-name">White</a><br />
      Special matching class for matching whitespace.
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing._PositionToken-class.html" class="summary-name" onclick="show_private();">_PositionToken</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.GoToColumn-class.html" class="summary-name">GoToColumn</a><br />
      Token to advance to a specific column of input text; useful for 
      tabular report scraping.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.LineStart-class.html" class="summary-name">LineStart</a><br />
      Matches if current position is at the beginning of a line within the 
      parse string
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.LineEnd-class.html" class="summary-name">LineEnd</a><br />
      Matches if current position is at the end of a line within the parse 
      string
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.StringStart-class.html" class="summary-name">StringStart</a><br />
      Matches if current position is at the beginning of the parse string
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.StringEnd-class.html" class="summary-name">StringEnd</a><br />
      Matches if current position is at the end of the parse string
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.WordStart-class.html" class="summary-name">WordStart</a><br />
      Matches if the current position is at the beginning of a Word, and is
      not preceded by any character in a given set of wordChars 
      (default=<code>printables</code>).
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.WordEnd-class.html" class="summary-name">WordEnd</a><br />
      Matches if the current position is at the end of a Word, and is not 
      followed by any character in a given set of wordChars 
      (default=<code>printables</code>).
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseExpression-class.html" class="summary-name">ParseExpression</a><br />
      Abstract subclass of ParserElement, for combining and post-processing
      parsed tokens.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.And-class.html" class="summary-name">And</a><br />
      Requires all given <code>ParseExpressions</code> to be found in the 
      given order.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Or-class.html" class="summary-name">Or</a><br />
      Requires that at least one <code>ParseExpression</code> is found.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.MatchFirst-class.html" class="summary-name">MatchFirst</a><br />
      Requires that at least one <code>ParseExpression</code> is found.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Each-class.html" class="summary-name">Each</a><br />
      Requires all given <code>ParseExpressions</code> to be found, but in 
      any order.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ParseElementEnhance-class.html" class="summary-name">ParseElementEnhance</a><br />
      Abstract subclass of <code>ParserElement</code>, for combining and 
      post-processing parsed tokens.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.FollowedBy-class.html" class="summary-name">FollowedBy</a><br />
      Lookahead matching of the given parse expression.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.NotAny-class.html" class="summary-name">NotAny</a><br />
      Lookahead to disallow matching with the given parse expression.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.ZeroOrMore-class.html" class="summary-name">ZeroOrMore</a><br />
      Optional repetition of zero or more of the given expression.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.OneOrMore-class.html" class="summary-name">OneOrMore</a><br />
      Repetition of one or more of the given expression.
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing._NullToken-class.html" class="summary-name" onclick="show_private();">_NullToken</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Optional-class.html" class="summary-name">Optional</a><br />
      Optional matching of the given expression.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.SkipTo-class.html" class="summary-name">SkipTo</a><br />
      Token for skipping over all undefined text until the matched 
      expression is found.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Forward-class.html" class="summary-name">Forward</a><br />
      Forward declaration of an expression to be defined later - used for 
      recursive grammars, such as algebraic infix notation.
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing._ForwardNoRecurse-class.html" class="summary-name" onclick="show_private();">_ForwardNoRecurse</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.TokenConverter-class.html" class="summary-name">TokenConverter</a><br />
      Abstract subclass of ParseExpression, for converting parsed results.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Upcase-class.html" class="summary-name">Upcase</a><br />
      Converter to upper case all matching tokens.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Combine-class.html" class="summary-name">Combine</a><br />
      Converter to concatenate all matching tokens to a single string.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Group-class.html" class="summary-name">Group</a><br />
      Converter to return the matched tokens as a list - useful for 
      returning tokens of ZeroOrMore and OneOrMore expressions.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Dict-class.html" class="summary-name">Dict</a><br />
      Converter to return a repetitive expression as a list, but also as a 
      dictionary.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.Suppress-class.html" class="summary-name">Suppress</a><br />
      Converter for ignoring the results of a parsed expression.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing.OnlyOnce-class.html" class="summary-name">OnlyOnce</a><br />
      Wrapper for parse actions, to ensure they are only called once.
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Functions</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Functions"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">character</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="unichr"></a><span class="summary-sig-name">unichr</span>(<span class="summary-sig-arg">i</span>)</span><br />
      Return a string of one character with ordinal i; 0 &lt;= i &lt; 256.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#_ustr" class="summary-sig-name" onclick="show_private();">_ustr</a>(<span class="summary-sig-arg">obj</span>)</span><br />
      Drop-in replacement for str(obj) that tries to be Unicode friendly.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_ustr">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_str2dict"></a><span class="summary-sig-name">_str2dict</span>(<span class="summary-sig-arg">strg</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_str2dict">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#_xml_escape" class="summary-sig-name" onclick="show_private();">_xml_escape</a>(<span class="summary-sig-arg">data</span>)</span><br />
      Escape &amp;, &lt;, &gt;, &quot;, ', etc.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_xml_escape">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#col" class="summary-sig-name">col</a>(<span class="summary-sig-arg">loc</span>,
        <span class="summary-sig-arg">strg</span>)</span><br />
      Returns current column within a string, counting newlines as line 
      separators.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#col">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#lineno" class="summary-sig-name">lineno</a>(<span class="summary-sig-arg">loc</span>,
        <span class="summary-sig-arg">strg</span>)</span><br />
      Returns current line number within a string, counting newlines as 
      line separators.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#lineno">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="line"></a><span class="summary-sig-name">line</span>(<span class="summary-sig-arg">loc</span>,
        <span class="summary-sig-arg">strg</span>)</span><br />
      Returns the line of text containing loc within a string, counting 
      newlines as line separators.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#line">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_defaultStartDebugAction"></a><span class="summary-sig-name">_defaultStartDebugAction</span>(<span class="summary-sig-arg">instring</span>,
        <span class="summary-sig-arg">loc</span>,
        <span class="summary-sig-arg">expr</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_defaultStartDebugAction">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_defaultSuccessDebugAction"></a><span class="summary-sig-name">_defaultSuccessDebugAction</span>(<span class="summary-sig-arg">instring</span>,
        <span class="summary-sig-arg">startloc</span>,
        <span class="summary-sig-arg">endloc</span>,
        <span class="summary-sig-arg">expr</span>,
        <span class="summary-sig-arg">toks</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_defaultSuccessDebugAction">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_defaultExceptionDebugAction"></a><span class="summary-sig-name">_defaultExceptionDebugAction</span>(<span class="summary-sig-arg">instring</span>,
        <span class="summary-sig-arg">loc</span>,
        <span class="summary-sig-arg">expr</span>,
        <span class="summary-sig-arg">exc</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_defaultExceptionDebugAction">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="nullDebugAction"></a><span class="summary-sig-name">nullDebugAction</span>(<span class="summary-sig-arg">*args</span>)</span><br />
      'Do-nothing' debug action, to suppress debugging output during 
      parsing.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#nullDebugAction">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="traceParseAction"></a><span class="summary-sig-name">traceParseAction</span>(<span class="summary-sig-arg">f</span>)</span><br />
      Decorator for debugging parse actions.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#traceParseAction">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#delimitedList" class="summary-sig-name">delimitedList</a>(<span class="summary-sig-arg">expr</span>,
        <span class="summary-sig-arg">delim</span>=<span class="summary-sig-default">&quot;,&quot;</span>,
        <span class="summary-sig-arg">combine</span>=<span class="summary-sig-default">False</span>)</span><br />
      Helper to define a delimited list of expressions - the delimiter 
      defaults to ','.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#delimitedList">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#countedArray" class="summary-sig-name">countedArray</a>(<span class="summary-sig-arg">expr</span>)</span><br />
      Helper to define a counted list of expressions.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#countedArray">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_flatten"></a><span class="summary-sig-name">_flatten</span>(<span class="summary-sig-arg">L</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_flatten">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#matchPreviousLiteral" class="summary-sig-name">matchPreviousLiteral</a>(<span class="summary-sig-arg">expr</span>)</span><br />
      Helper to define an expression that is indirectly defined from the 
      tokens matched in a previous expression, that is, it looks for a 
      'repeat' of a previous expression.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#matchPreviousLiteral">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#matchPreviousExpr" class="summary-sig-name">matchPreviousExpr</a>(<span class="summary-sig-arg">expr</span>)</span><br />
      Helper to define an expression that is indirectly defined from the 
      tokens matched in a previous expression, that is, it looks for a 
      'repeat' of a previous expression.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#matchPreviousExpr">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_escapeRegexRangeChars"></a><span class="summary-sig-name">_escapeRegexRangeChars</span>(<span class="summary-sig-arg">s</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_escapeRegexRangeChars">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#oneOf" class="summary-sig-name">oneOf</a>(<span class="summary-sig-arg">strs</span>,
        <span class="summary-sig-arg">caseless</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">useRegex</span>=<span class="summary-sig-default">True</span>)</span><br />
      Helper to quickly define a set of alternative Literals, and makes 
      sure to do longest-first testing when there is a conflict, regardless
      of the input order, but returns a <code>MatchFirst</code> for best 
      performance.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#oneOf">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#dictOf" class="summary-sig-name">dictOf</a>(<span class="summary-sig-arg">key</span>,
        <span class="summary-sig-arg">value</span>)</span><br />
      Helper to easily and clearly define a dictionary by specifying the 
      respective patterns for the key and value.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#dictOf">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#originalTextFor" class="summary-sig-name">originalTextFor</a>(<span class="summary-sig-arg">expr</span>,
        <span class="summary-sig-arg">asString</span>=<span class="summary-sig-default">True</span>)</span><br />
      Helper to return the original, untokenized text for a given 
      expression.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#originalTextFor">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#srange" class="summary-sig-name">srange</a>(<span class="summary-sig-arg">s</span>)</span><br />
      Helper to easily define string ranges for use in Word construction.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#srange">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="matchOnlyAtCol"></a><span class="summary-sig-name">matchOnlyAtCol</span>(<span class="summary-sig-arg">n</span>)</span><br />
      Helper method for defining parse actions that require matching at a 
      specific column in the input text.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#matchOnlyAtCol">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#replaceWith" class="summary-sig-name">replaceWith</a>(<span class="summary-sig-arg">replStr</span>)</span><br />
      Helper method for common parse actions that simply return a literal 
      value.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#replaceWith">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#removeQuotes" class="summary-sig-name">removeQuotes</a>(<span class="summary-sig-arg">s</span>,
        <span class="summary-sig-arg">l</span>,
        <span class="summary-sig-arg">t</span>)</span><br />
      Helper parse action for removing quotation marks from parsed quoted 
      strings.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#removeQuotes">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="upcaseTokens"></a><span class="summary-sig-name">upcaseTokens</span>(<span class="summary-sig-arg">s</span>,
        <span class="summary-sig-arg">l</span>,
        <span class="summary-sig-arg">t</span>)</span><br />
      Helper parse action to convert tokens to upper case.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#upcaseTokens">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="downcaseTokens"></a><span class="summary-sig-name">downcaseTokens</span>(<span class="summary-sig-arg">s</span>,
        <span class="summary-sig-arg">l</span>,
        <span class="summary-sig-arg">t</span>)</span><br />
      Helper parse action to convert tokens to lower case.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#downcaseTokens">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#keepOriginalText" class="summary-sig-name">keepOriginalText</a>(<span class="summary-sig-arg">s</span>,
        <span class="summary-sig-arg">startLoc</span>,
        <span class="summary-sig-arg">t</span>)</span><br />
      DEPRECATED - use new helper method <code>originalTextFor</code>.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#keepOriginalText">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="getTokensEndLoc"></a><span class="summary-sig-name">getTokensEndLoc</span>()</span><br />
      Method to be called from within a parse action to determine the end 
      location of the parsed tokens.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#getTokensEndLoc">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="_makeTags"></a><span class="summary-sig-name">_makeTags</span>(<span class="summary-sig-arg">tagStr</span>,
        <span class="summary-sig-arg">xml</span>)</span><br />
      Internal helper to construct opening and closing tag expressions, 
      given a tag name</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_makeTags">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="makeHTMLTags"></a><span class="summary-sig-name">makeHTMLTags</span>(<span class="summary-sig-arg">tagStr</span>)</span><br />
      Helper to construct opening and closing tag expressions for HTML, 
      given a tag name</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#makeHTMLTags">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="makeXMLTags"></a><span class="summary-sig-name">makeXMLTags</span>(<span class="summary-sig-arg">tagStr</span>)</span><br />
      Helper to construct opening and closing tag expressions for XML, 
      given a tag name</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#makeXMLTags">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#withAttribute" class="summary-sig-name">withAttribute</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**attrDict</span>)</span><br />
      Helper to create a validating parse action to be used with start tags
      created with makeXMLTags or makeHTMLTags.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#withAttribute">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#operatorPrecedence" class="summary-sig-name">operatorPrecedence</a>(<span class="summary-sig-arg">baseExpr</span>,
        <span class="summary-sig-arg">opList</span>)</span><br />
      Helper method for constructing grammars of expressions made up of 
      operators working in a precedence hierarchy.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#operatorPrecedence">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#nestedExpr" class="summary-sig-name">nestedExpr</a>(<span class="summary-sig-arg">opener</span>=<span class="summary-sig-default">&quot;(&quot;</span>,
        <span class="summary-sig-arg">closer</span>=<span class="summary-sig-default">&quot;)&quot;</span>,
        <span class="summary-sig-arg">content</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ignoreExpr</span>=<span class="summary-sig-default">quotedString.copy()</span>)</span><br />
      Helper method for defining nested lists enclosed in opening and 
      closing delimiters (&quot;(&quot; and &quot;)&quot; are the default).</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#nestedExpr">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="taskcoachlib.thirdparty.pyparsing-module.html#indentedBlock" class="summary-sig-name">indentedBlock</a>(<span class="summary-sig-arg">blockStatementExpr</span>,
        <span class="summary-sig-arg">indentStack</span>,
        <span class="summary-sig-arg">indent</span>=<span class="summary-sig-default">True</span>)</span><br />
      Helper method for defining space-delimited indentation blocks, such 
      as those used to define block statements in Python source code.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#indentedBlock">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Variables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#__doc__" class="summary-name" onclick="show_private();">__doc__</a> = <code title="&quot;&quot;&quot;
pyparsing module - Classes and methods to define and execute parsing g\
rammars

The pyparsing module is an alternative approach to creating and execut\
ing simple grammars,
vs. the traditional lex/yacc approach, or the use of regular expressio\
ns.  With pyparsing, you
...">&quot;<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__versionTime__"></a><span class="summary-name">__versionTime__</span> = <code title="&quot;12 Aug 2010 03:56&quot;">&quot;12 Aug 2010 03:56&quot;</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_PY3K"></a><span class="summary-name">_PY3K</span> = <code title="sys.version_info [0] &gt; 2">sys.version_info [0] &gt; 2</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_MAX_INT"></a><span class="summary-name">_MAX_INT</span> = <code title="sys.maxint">sys.maxint</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="alphas"></a><span class="summary-name">alphas</span> = <code title="string.lowercase+ string.uppercase">string.lowercase+ string.uppercase</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="singleArgBuiltins"></a><span class="summary-name">singleArgBuiltins</span> = <code title="[]">[]</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="nums"></a><span class="summary-name">nums</span> = <code title="string.digits">string.digits</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="hexnums"></a><span class="summary-name">hexnums</span> = <code title="nums+ &quot;ABCDEFabcdef&quot;">nums+ &quot;ABCDEFabcdef&quot;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="alphanums"></a><span class="summary-name">alphanums</span> = <code title="alphas+ nums">alphas+ nums</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_bslash"></a><span class="summary-name">_bslash</span> = <code title="chr(92)">chr(92)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#printables" class="summary-name">printables</a> = <code title="&quot;&quot;.join([c for c in string.printable if c not in string.whitespace])">&quot;&quot;.join([c for c in string.printable if c not in <code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_optionalNotMatched"></a><span class="summary-name">_optionalNotMatched</span> = <code title="_NullToken()">_NullToken()</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="empty"></a><span class="summary-name">empty</span> = <code title="Empty().setName(&quot;empty&quot;)">Empty().setName(&quot;empty&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="lineStart"></a><span class="summary-name">lineStart</span> = <code title="LineStart().setName(&quot;lineStart&quot;)">LineStart().setName(&quot;lineStart&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="lineEnd"></a><span class="summary-name">lineEnd</span> = <code title="LineEnd().setName(&quot;lineEnd&quot;)">LineEnd().setName(&quot;lineEnd&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="stringStart"></a><span class="summary-name">stringStart</span> = <code title="StringStart().setName(&quot;stringStart&quot;)">StringStart().setName(&quot;stringStart&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="stringEnd"></a><span class="summary-name">stringEnd</span> = <code title="StringEnd().setName(&quot;stringEnd&quot;)">StringEnd().setName(&quot;stringEnd&quot;)</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_escapedPunc" class="summary-name" onclick="show_private();">_escapedPunc</a> = <code title="Word(_bslash, r&quot;\[]-*.$+^?()~ &quot;, exact= 2).setParseAction(lambda s, l,\
 t: t [0] [1])">Word(_bslash, r&quot;\[]-*.$+^?()~ &quot;, exact= 2).setP<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_printables_less_backslash" class="summary-name" onclick="show_private();">_printables_less_backslash</a> = <code title="&quot;&quot;.join([c for c in printables if c not in r&quot;\]&quot;])">&quot;&quot;.join([c for c in printables if<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_escapedHexChar" class="summary-name" onclick="show_private();">_escapedHexChar</a> = <code title="Combine(Suppress(_bslash+ &quot;0x&quot;)+ Word(hexnums)).setParseAction(lambda \
s, l, t: unichr(int(t [0], 16)))">Combine(Suppress(_bslash+ &quot;0x&quot;)+ Word(hexnum<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_escapedOctChar" class="summary-name" onclick="show_private();">_escapedOctChar</a> = <code title="Combine(Suppress(_bslash)+ Word(&quot;0&quot;, &quot;01234567&quot;)).setParseAction(lambd\
a s, l, t: unichr(int(t [0], 8)))">Combine(Suppress(_bslash)+ Word(&quot;0&quot;, &quot;012345<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_singleChar" class="summary-name" onclick="show_private();">_singleChar</a> = <code title="_escapedPunc | _escapedHexChar | _escapedOctChar | Word(_printables_le\
ss_backslash, exact= 1)">_escapedPunc | _escapedHexChar | _escapedOctChar<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_charRange"></a><span class="summary-name">_charRange</span> = <code title="Group(_singleChar+ Suppress(&quot;-&quot;)+ _singleChar)">Group(_singleChar+ Suppress(&quot;-&quot;)+ _singleChar)</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_reBracketExpr" class="summary-name" onclick="show_private();">_reBracketExpr</a> = <code title="Literal(&quot;[&quot;)+ Optional(&quot;^&quot;).setResultsName(&quot;negate&quot;)+ Group(OneOrMore(\
_charRange | _singleChar)).setResultsName(&quot;body&quot;)+ &quot;]&quot;">Literal(&quot;[&quot;)+ Optional(&quot;^&quot;).setResultsName(&quot;n<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_expanded"></a><span class="summary-name">_expanded</span> = <code title="lambda p:">lambda p:</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="opAssoc"></a><span class="summary-name">opAssoc</span> = <code title="_Constants()">_Constants()</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#dblQuotedString" class="summary-name">dblQuotedString</a> = <code title="Regex(r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\x[0-9a-fA-F]+)|(?:\\.))*&quot;').setName\
(&quot;string enclosed in double quotes&quot;)">Regex(r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\x[0-9a-fA<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#sglQuotedString" class="summary-name">sglQuotedString</a> = <code title="Regex(r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*'&quot;).setName\
(&quot;string enclosed in single quotes&quot;)">Regex(r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#quotedString" class="summary-name">quotedString</a> = <code title="Regex(r'''(?:&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\x[0-9a-fA-F]+)|(?:\\.))*&quot;)|(?:\
'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*')''').setName(&quot;quo\
tedString using single or double quotes&quot;)">Regex(r'''(?:&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\x[0-9a-<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="unicodeString"></a><span class="summary-name">unicodeString</span> = <code title="Combine(_L('u')+ quotedString.copy())">Combine(_L('u')+ quotedString.copy())</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="alphas8bit"></a><span class="summary-name">alphas8bit</span> = <code title="srange(r&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;)">srange(r&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="punc8bit"></a><span class="summary-name">punc8bit</span> = <code title="srange(r&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;)">srange(r&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#commonHTMLEntity" class="summary-name">commonHTMLEntity</a> = <code title="Combine(_L(&quot;&amp;&quot;)+ oneOf(&quot;gt lt amp nbsp quot&quot;).setResultsName(&quot;entity&quot;)\
+ &quot;;&quot;).streamline()">Combine(_L(&quot;&amp;&quot;)+ oneOf(&quot;gt lt amp nbsp quot<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_htmlEntityMap" class="summary-name" onclick="show_private();">_htmlEntityMap</a> = <code title="dict(zip(&quot;gt lt amp nbsp quot&quot;.split(), '&gt;&lt;&amp; &quot;'))">dict(zip(&quot;gt lt amp nbsp quot&quot;.split(), '&gt;&lt;&amp; <code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="replaceHTMLEntity"></a><span class="summary-name">replaceHTMLEntity</span> = <code title="lambda t:">lambda t:</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#cStyleComment" class="summary-name">cStyleComment</a> = <code title="Regex(r&quot;/\*(?:[^*]*\*+)+?/&quot;).setName(&quot;C style comment&quot;)">Regex(r&quot;/\*(?:[^*]*\*+)+?/&quot;).setName(&quot;C style <code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="htmlComment"></a><span class="summary-name">htmlComment</span> = <code title="Regex(r&quot;&lt;!--[\s\S]*?--&gt;&quot;)">Regex(r&quot;&lt;!--[\s\S]*?--&gt;&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="restOfLine"></a><span class="summary-name">restOfLine</span> = <code title="Regex(r&quot;.*&quot;).leaveWhitespace()">Regex(r&quot;.*&quot;).leaveWhitespace()</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="dblSlashComment"></a><span class="summary-name">dblSlashComment</span> = <code title="Regex(r&quot;\/\/(\\\n|.)*&quot;).setName(&quot;// comment&quot;)">Regex(r&quot;\/\/(\\\n|.)*&quot;).setName(&quot;// comment&quot;)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#cppStyleComment" class="summary-name">cppStyleComment</a> = <code title="Regex(r&quot;/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^\n]*)*?(?:(?&lt;!\\)|\Z))&quot;).s\
etName(&quot;C++ style comment&quot;)">Regex(r&quot;/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#javaStyleComment" class="summary-name">javaStyleComment</a> = <code title="Regex(r&quot;/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^\n]*)*?(?:(?&lt;!\\)|\Z))&quot;).s\
etName(&quot;C++ style comment&quot;)">Regex(r&quot;/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#pythonStyleComment" class="summary-name">pythonStyleComment</a> = <code title="Regex(r&quot;#.*&quot;).setName(&quot;Python style comment&quot;)">Regex(r&quot;#.*&quot;).setName(&quot;Python style comme<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="_noncomma"></a><span class="summary-name">_noncomma</span> = <code title="&quot;&quot;.join([c for c in printables if c != &quot;,&quot;])">&quot;&quot;.join([c for c in printables if c != &quot;,&quot;])</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#_commasepitem" class="summary-name" onclick="show_private();">_commasepitem</a> = <code title="Combine(OneOrMore(Word(_noncomma)+ Optional(Word(&quot; \t&quot;)+ ~ Literal(&quot;,&quot;\
)+ ~ LineEnd()))).streamline().setName(&quot;commaItem&quot;)">Combine(OneOrMore(Word(_noncomma)+ Optional(Wo<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="taskcoachlib.thirdparty.pyparsing-module.html#commaSeparatedList" class="summary-name">commaSeparatedList</a> = <code title="delimitedList(Optional(quotedString.copy() | _commasepitem, default= &quot;\
&quot;)).setName(&quot;commaSeparatedList&quot;)">delimitedList(Optional(quotedString.copy(<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Function Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-FunctionDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="_ustr"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">_ustr</span>(<span class="sig-arg">obj</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_ustr">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Drop-in replacement for str(obj) that tries to be Unicode friendly. It
  first tries str(obj). If that fails with a UnicodeEncodeError, then it 
  tries unicode(obj). It then &lt; returns the unicode object | encodes it 
  with the default encoding | ... &gt;.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="_xml_escape"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">_xml_escape</span>(<span class="sig-arg">data</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#_xml_escape">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Escape &amp;, &lt;, &gt;, &quot;, ', etc. in a string of data.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="col"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">col</span>(<span class="sig-arg">loc</span>,
        <span class="sig-arg">strg</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#col">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns current column within a string, counting newlines as line 
  separators. The first column is number 1.</p>
  <p>Note: the default parsing behavior is to expand tabs in the input 
  string before starting the parsing process.  See <a 
  href="taskcoachlib.thirdparty.pyparsing.ParserElement-class.html#parseString"
  class="link"><i>ParserElement.parseString</i></a> for more information on
  parsing strings containing &lt;TAB&gt;s, and suggested methods to 
  maintain a consistent view of the parsed string, the parse location, and 
  line and column positions within the parsed string.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="lineno"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">lineno</span>(<span class="sig-arg">loc</span>,
        <span class="sig-arg">strg</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#lineno">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns current line number within a string, counting newlines as line
  separators. The first line is number 1.</p>
  <p>Note: the default parsing behavior is to expand tabs in the input 
  string before starting the parsing process.  See <a 
  href="taskcoachlib.thirdparty.pyparsing.ParserElement-class.html#parseString"
  class="link"><i>ParserElement.parseString</i></a> for more information on
  parsing strings containing &lt;TAB&gt;s, and suggested methods to 
  maintain a consistent view of the parsed string, the parse location, and 
  line and column positions within the parsed string.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="delimitedList"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">delimitedList</span>(<span class="sig-arg">expr</span>,
        <span class="sig-arg">delim</span>=<span class="sig-default">&quot;,&quot;</span>,
        <span class="sig-arg">combine</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#delimitedList">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to define a delimited list of expressions - the delimiter 
  defaults to ','. By default, the list elements and delimiters can have 
  intervening whitespace, and comments, but this can be overridden by 
  passing <code>combine=True</code> in the constructor. If 
  <code>combine</code> is set to True, the matching tokens are returned as 
  a single token string, with the delimiters included; otherwise, the 
  matching tokens are returned as a list of tokens, with the delimiters 
  suppressed.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="countedArray"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">countedArray</span>(<span class="sig-arg">expr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#countedArray">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to define a counted list of expressions. This helper defines a 
  pattern of the form:</p>
<pre class="literalblock">
   integer expr expr expr...
</pre>
  <p>where the leading integer tells how many expr expressions follow. The 
  matched tokens returns the array of expr tokens as a list - the leading 
  count token is suppressed.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="matchPreviousLiteral"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">matchPreviousLiteral</span>(<span class="sig-arg">expr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#matchPreviousLiteral">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to define an expression that is indirectly defined from the 
  tokens matched in a previous expression, that is, it looks for a 'repeat'
  of a previous expression.  For example:</p>
<pre class="literalblock">
   first = Word(nums)
   second = matchPreviousLiteral(first)
   matchExpr = first + &quot;:&quot; + second
</pre>
  <p>will match <code>&quot;1:1&quot;</code>, but not 
  <code>&quot;1:2&quot;</code>.  Because this matches a previous literal, 
  will also match the leading <code>&quot;1:1&quot;</code> in 
  <code>&quot;1:10&quot;</code>. If this is not desired, use 
  <code>matchPreviousExpr</code>. Do *not* use with packrat parsing 
  enabled.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="matchPreviousExpr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">matchPreviousExpr</span>(<span class="sig-arg">expr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#matchPreviousExpr">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to define an expression that is indirectly defined from the 
  tokens matched in a previous expression, that is, it looks for a 'repeat'
  of a previous expression.  For example:</p>
<pre class="literalblock">
   first = Word(nums)
   second = matchPreviousExpr(first)
   matchExpr = first + &quot;:&quot; + second
</pre>
  <p>will match <code>&quot;1:1&quot;</code>, but not 
  <code>&quot;1:2&quot;</code>.  Because this matches by expressions, will 
  *not* match the leading <code>&quot;1:1&quot;</code> in 
  <code>&quot;1:10&quot;</code>; the expressions are evaluated first, and 
  then compared, so <code>&quot;1&quot;</code> is compared with 
  <code>&quot;10&quot;</code>. Do *not* use with packrat parsing 
  enabled.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="oneOf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">oneOf</span>(<span class="sig-arg">strs</span>,
        <span class="sig-arg">caseless</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">useRegex</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#oneOf">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to quickly define a set of alternative Literals, and makes sure
  to do longest-first testing when there is a conflict, regardless of the 
  input order, but returns a <code>MatchFirst</code> for best 
  performance.</p>
  <p>Parameters:</p>
  <ul>
    <li>
      strs - a string of space-delimited literals, or a list of string 
      literals
    </li>
    <li>
      caseless - (default=False) - treat all literals as caseless
    </li>
    <li>
      useRegex - (default=True) - as an optimization, will generate a Regex
      object; otherwise, will generate a <code>MatchFirst</code> object (if
      <code>caseless=True</code>, or if creating a <code>Regex</code> 
      raises an exception)
    </li>
  </ul>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dictOf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dictOf</span>(<span class="sig-arg">key</span>,
        <span class="sig-arg">value</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#dictOf">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to easily and clearly define a dictionary by specifying the 
  respective patterns for the key and value.  Takes care of defining the 
  <code>Dict</code>, <code>ZeroOrMore</code>, and <code>Group</code> tokens
  in the proper order.  The key pattern can include delimiting markers or 
  punctuation, as long as they are suppressed, thereby leaving the 
  significant key text.  The value pattern can include named results, so 
  that the <code>Dict</code> results can include named token fields.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="originalTextFor"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">originalTextFor</span>(<span class="sig-arg">expr</span>,
        <span class="sig-arg">asString</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#originalTextFor">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to return the original, untokenized text for a given 
  expression.  Useful to restore the parsed fields of an HTML start tag 
  into the raw tag text itself, or to revert separate tokens with 
  intervening whitespace back to the original matching input text. Simpler 
  to use than the parse action <code>keepOriginalText</code>, and does not 
  require the inspect module to chase up the call stack.  By default, 
  returns a string containing the original parsed text.</p>
  <p>If the optional <code>asString</code> argument is passed as False, 
  then the return value is a <code>ParseResults</code> containing any 
  results names that were originally matched, and a single token containing
  the original matched text from the input string.  So if the expression 
  passed to <code>originalTextFor</code> contains expressions with defined 
  results names, you must set <code>asString</code> to False if you want to
  preserve those results name values.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="srange"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">srange</span>(<span class="sig-arg">s</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#srange">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to easily define string ranges for use in Word construction.  
  Borrows syntax from regexp '[]' string range definitions:</p>
<pre class="literalblock">
  srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot;
  srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;
  srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot;
</pre>
  <p>The input string must be enclosed in []'s, and the returned string is 
  the expanded character set joined into a single string. The values 
  enclosed in the []'s may be:</p>
<pre class="literalblock">
  a single character
  an escaped character with a leading backslash (such as \- or \])
  an escaped hex character with a leading '\0x' (\0x21, which is a '!' character)
  an escaped octal character with a leading '\0' (\041, which is a '!' character)
  a range of any of the above, separated by a dash ('a-z', etc.)
  any combination of the above ('aeiouy', 'a-zA-Z0-9_$', etc.)
</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="replaceWith"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">replaceWith</span>(<span class="sig-arg">replStr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#replaceWith">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper method for common parse actions that simply return a literal 
  value.  Especially useful when used with 
  <code>transformString()</code>.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="removeQuotes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">removeQuotes</span>(<span class="sig-arg">s</span>,
        <span class="sig-arg">l</span>,
        <span class="sig-arg">t</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#removeQuotes">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper parse action for removing quotation marks from parsed quoted 
  strings. To use, add this parse action to quoted string using:</p>
<pre class="literalblock">
 quotedString.setParseAction( removeQuotes )
</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="keepOriginalText"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">keepOriginalText</span>(<span class="sig-arg">s</span>,
        <span class="sig-arg">startLoc</span>,
        <span class="sig-arg">t</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#keepOriginalText">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>DEPRECATED - use new helper method <code>originalTextFor</code>. 
  Helper parse action to preserve original parsed text, overriding any 
  nested parse actions.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="withAttribute"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">withAttribute</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**attrDict</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#withAttribute">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper to create a validating parse action to be used with start tags 
  created with makeXMLTags or makeHTMLTags. Use withAttribute to qualify a 
  starting tag with a required attribute value, to avoid false matches on 
  common tags such as &lt;TD&gt; or &lt;DIV&gt;.</p>
  <p>Call withAttribute with a series of attribute names and values. 
  Specify the list of filter attributes names and values as:</p>
  <ul>
    <li>
      keyword arguments, as in 
      (class=&quot;Customer&quot;,align=&quot;right&quot;), or
    </li>
    <li>
      a list of name-value tuples, as in ( (&quot;ns1:class&quot;, 
      &quot;Customer&quot;), (&quot;ns2:align&quot;,&quot;right&quot;) )
    </li>
  </ul>
  <p>For attribute names with a namespace prefix, you must use the second 
  form.  Attribute names are matched insensitive to upper/lower case.</p>
  <p>To verify that the attribute exists, but without specifying a value, 
  pass withAttribute.ANY_VALUE as the value.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="operatorPrecedence"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">operatorPrecedence</span>(<span class="sig-arg">baseExpr</span>,
        <span class="sig-arg">opList</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#operatorPrecedence">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper method for constructing grammars of expressions made up of 
  operators working in a precedence hierarchy.  Operators may be unary or 
  binary, left- or right-associative.  Parse actions can also be attached 
  to operator expressions.</p>
  <p>Parameters:</p>
  <ul>
    <li>
      baseExpr - expression representing the most basic element for the 
      nested
    </li>
    <li>
      opList - list of tuples, one for each operator precedence level in 
      the expression grammar; each tuple is of the form (opExpr, numTerms, 
      rightLeftAssoc, parseAction), where:
      <ul>
        <li>
          opExpr is the pyparsing expression for the operator; may also be 
          a string, which will be converted to a Literal; if numTerms is 3,
          opExpr is a tuple of two expressions, for the two operators 
          separating the 3 terms
        </li>
        <li>
          numTerms is the number of terms for this operator (must be 1, 2, 
          or 3)
        </li>
        <li>
          rightLeftAssoc is the indicator whether the operator is right or 
          left associative, using the pyparsing-defined constants 
          opAssoc.RIGHT and opAssoc.LEFT.
        </li>
        <li>
          parseAction is the parse action to be associated with expressions
          matching this operator expression (the parse action tuple member 
          may be omitted)
        </li>
      </ul>
    </li>
  </ul>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nestedExpr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nestedExpr</span>(<span class="sig-arg">opener</span>=<span class="sig-default">&quot;(&quot;</span>,
        <span class="sig-arg">closer</span>=<span class="sig-default">&quot;)&quot;</span>,
        <span class="sig-arg">content</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ignoreExpr</span>=<span class="sig-default">quotedString.copy()</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#nestedExpr">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper method for defining nested lists enclosed in opening and 
  closing delimiters (&quot;(&quot; and &quot;)&quot; are the default).</p>
  <p>Parameters:</p>
  <ul>
    <li>
      opener - opening character for a nested list (default=&quot;(&quot;);
      can also be a pyparsing expression
    </li>
    <li>
      closer - closing character for a nested list (default=&quot;)&quot;);
      can also be a pyparsing expression
    </li>
    <li>
      content - expression for items within the nested lists (default=None)
    </li>
    <li>
      ignoreExpr - expression for ignoring opening and closing delimiters 
      (default=quotedString)
    </li>
  </ul>
  <p>If an expression is not provided for the content argument, the nested 
  expression will capture all whitespace-delimited content between 
  delimiters as a list of separate values.</p>
  <p>Use the ignoreExpr argument to define expressions that may contain 
  opening or closing characters that should not be treated as opening or 
  closing characters for nesting, such as quotedString or a comment 
  expression.  Specify multiple expressions using an Or or MatchFirst. The 
  default is quotedString, but if no expressions are to be ignored, then 
  pass None for this argument.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="indentedBlock"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">indentedBlock</span>(<span class="sig-arg">blockStatementExpr</span>,
        <span class="sig-arg">indentStack</span>,
        <span class="sig-arg">indent</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="taskcoachlib.thirdparty.pyparsing-pysrc.html#indentedBlock">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Helper method for defining space-delimited indentation blocks, such as
  those used to define block statements in Python source code.</p>
  <p>Parameters:</p>
  <ul>
    <li>
      blockStatementExpr - expression defining syntax of statement that is 
      repeated within the indented block
    </li>
    <li>
      indentStack - list created by caller to manage indentation stack 
      (multiple statementWithIndentedBlock expressions within a single 
      grammar should share a common indentStack)
    </li>
    <li>
      indent - boolean indicating whether block must be indented beyond the
      the current level; set to False for block of left-most statements 
      (default=True)
    </li>
  </ul>
  <p>A valid block must contain at least one blockStatement.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== VARIABLES DETAILS ==================== -->
<a name="section-VariablesDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-VariablesDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="__doc__"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">__doc__</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
&quot;&quot;&quot;
pyparsing module - Classes and methods to define and execute parsing g<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
rammars

The pyparsing module is an alternative approach to creating and execut<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
ing simple grammars,
vs. the traditional lex/yacc approach, or the use of regular expressio<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
ns.  With pyparsing, you
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="printables"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">printables</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
&quot;&quot;.join([c for c in string.printable if c not in string.whitespace])
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_escapedPunc"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_escapedPunc</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Word(_bslash, r&quot;\[]-*.$+^?()~ &quot;, exact= 2).setParseAction(lambda s, l,<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
 t: t [0] [1])
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_printables_less_backslash"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_printables_less_backslash</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
&quot;&quot;.join([c for c in printables if c not in r&quot;\]&quot;])
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_escapedHexChar"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_escapedHexChar</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Combine(Suppress(_bslash+ &quot;0x&quot;)+ Word(hexnums)).setParseAction(lambda <span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
s, l, t: unichr(int(t [0], 16)))
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_escapedOctChar"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_escapedOctChar</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Combine(Suppress(_bslash)+ Word(&quot;0&quot;, &quot;01234567&quot;)).setParseAction(lambd<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
a s, l, t: unichr(int(t [0], 8)))
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_singleChar"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_singleChar</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
_escapedPunc | _escapedHexChar | _escapedOctChar | Word(_printables_le<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
ss_backslash, exact= 1)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_reBracketExpr"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_reBracketExpr</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Literal(&quot;[&quot;)+ Optional(&quot;^&quot;).setResultsName(&quot;negate&quot;)+ Group(OneOrMore(<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
_charRange | _singleChar)).setResultsName(&quot;body&quot;)+ &quot;]&quot;
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="dblQuotedString"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">dblQuotedString</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\x[0-9a-fA-F]+)|(?:\\.))*&quot;').setName<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
(&quot;string enclosed in double quotes&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="sglQuotedString"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">sglQuotedString</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*'&quot;).setName<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
(&quot;string enclosed in single quotes&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="quotedString"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">quotedString</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r'''(?:&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\x[0-9a-fA-F]+)|(?:\\.))*&quot;)|(?:<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
'(?:[^'\n\r\\]|(?:'')|(?:\\x[0-9a-fA-F]+)|(?:\\.))*')''').setName(&quot;quo<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
tedString using single or double quotes&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="commonHTMLEntity"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">commonHTMLEntity</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Combine(_L(&quot;&amp;&quot;)+ oneOf(&quot;gt lt amp nbsp quot&quot;).setResultsName(&quot;entity&quot;)<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
+ &quot;;&quot;).streamline()
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_htmlEntityMap"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_htmlEntityMap</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
dict(zip(&quot;gt lt amp nbsp quot&quot;.split(), '&gt;&lt;&amp; &quot;'))
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="cStyleComment"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">cStyleComment</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r&quot;/\*(?:[^*]*\*+)+?/&quot;).setName(&quot;C style comment&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="cppStyleComment"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">cppStyleComment</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r&quot;/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^\n]*)*?(?:(?&lt;!\\)|\Z))&quot;).s<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
etName(&quot;C++ style comment&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="javaStyleComment"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">javaStyleComment</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r&quot;/(?:\*(?:[^*]*\*+)+?/|/[^\n]*(?:\n[^\n]*)*?(?:(?&lt;!\\)|\Z))&quot;).s<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
etName(&quot;C++ style comment&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="pythonStyleComment"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">pythonStyleComment</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Regex(r&quot;#.*&quot;).setName(&quot;Python style comment&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="_commasepitem"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">_commasepitem</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
Combine(OneOrMore(Word(_noncomma)+ Optional(Word(&quot; \t&quot;)+ ~ Literal(&quot;,&quot;<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
)+ ~ LineEnd()))).streamline().setName(&quot;commaItem&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="commaSeparatedList"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">commaSeparatedList</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
delimitedList(Optional(quotedString.copy() | _commasepitem, default= &quot;<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
&quot;)).setName(&quot;commaSeparatedList&quot;)
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Mon Nov 25 04:13:32 2013
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
